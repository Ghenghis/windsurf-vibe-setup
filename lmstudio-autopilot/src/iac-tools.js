#!/usr/bin/env node
/**
 * Windsurf Autopilot - Infrastructure as Code Tools v3.1
 * 
 * Terraform, Kubernetes, and Helm integration.
 */

const fs = require('fs');
const path = require('path');
const { execSync, spawn } = require('child_process');

// Data directory
const DATA_DIR = process.platform === 'win32'
  ? path.join(process.env.APPDATA || '', 'WindsurfAutopilot')
  : path.join(process.env.HOME || '', '.windsurf-autopilot');

const IAC_DIR = path.join(DATA_DIR, 'iac');

// Ensure directories exist
if (!fs.existsSync(IAC_DIR)) {
  fs.mkdirSync(IAC_DIR, { recursive: true });
}

const iacTools = {

  // Initialize Terraform in project
  terraform_init: {
    name: 'terraform_init',
    description: 'Initialize Terraform in project with provider configuration',
    inputSchema: {
      type: 'object',
      properties: {
        path: { type: 'string', description: 'Path to Terraform project' },
        backend: { 
          type: 'object', 
          description: 'Backend configuration (s3, gcs, azurerm, local)',
          properties: {
            type: { type: 'string' },
            config: { type: 'object' }
          }
        },
        providers: {
          type: 'array',
          items: { type: 'string' },
          description: 'Providers to configure (aws, gcp, azure, etc.)'
        }
      },
      required: ['path']
    },
    handler: async (args) => {
      const projectPath = args.path;
      const backend = args.backend || { type: 'local' };
      const providers = args.providers || [];

      // Check if terraform is installed
      try {
        execSync('terraform --version', { encoding: 'utf8' });
      } catch {
        return {
          success: false,
          error: 'Terraform is not installed. Install from https://terraform.io/downloads'
        };
      }

      // Ensure directory exists
      if (!fs.existsSync(projectPath)) {
        fs.mkdirSync(projectPath, { recursive: true });
      }

      // Generate main.tf if not exists
      const mainTf = path.join(projectPath, 'main.tf');
      if (!fs.existsSync(mainTf)) {
        let tfContent = `# Terraform configuration generated by Windsurf Autopilot
# Version: 3.1.0

terraform {
  required_version = ">= 1.0.0"
`;
        // Add backend
        if (backend.type === 's3') {
          tfContent += `
  backend "s3" {
    bucket = "${backend.config?.bucket || 'terraform-state'}"
    key    = "${backend.config?.key || 'state/terraform.tfstate'}"
    region = "${backend.config?.region || 'us-east-1'}"
  }
`;
        } else if (backend.type === 'gcs') {
          tfContent += `
  backend "gcs" {
    bucket = "${backend.config?.bucket || 'terraform-state'}"
    prefix = "${backend.config?.prefix || 'terraform/state'}"
  }
`;
        }

        // Add required providers
        if (providers.length > 0) {
          tfContent += `
  required_providers {
`;
          for (const provider of providers) {
            if (provider === 'aws') {
              tfContent += `    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
`;
            } else if (provider === 'gcp' || provider === 'google') {
              tfContent += `    google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
`;
            } else if (provider === 'azure' || provider === 'azurerm') {
              tfContent += `    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 3.0"
    }
`;
            } else if (provider === 'kubernetes' || provider === 'k8s') {
              tfContent += `    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = "~> 2.0"
    }
`;
            }
          }
          tfContent += `  }
`;
        }

        tfContent += `}

# Provider configuration
`;
        // Add provider blocks
        for (const provider of providers) {
          if (provider === 'aws') {
            tfContent += `
provider "aws" {
  region = var.aws_region
}
`;
          } else if (provider === 'gcp' || provider === 'google') {
            tfContent += `
provider "google" {
  project = var.gcp_project
  region  = var.gcp_region
}
`;
          } else if (provider === 'azure' || provider === 'azurerm') {
            tfContent += `
provider "azurerm" {
  features {}
}
`;
          }
        }

        fs.writeFileSync(mainTf, tfContent);
      }

      // Generate variables.tf
      const varsTf = path.join(projectPath, 'variables.tf');
      if (!fs.existsSync(varsTf)) {
        let varsContent = `# Variables for Terraform configuration

`;
        for (const provider of providers) {
          if (provider === 'aws') {
            varsContent += `variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}

`;
          } else if (provider === 'gcp' || provider === 'google') {
            varsContent += `variable "gcp_project" {
  description = "GCP project ID"
  type        = string
}

variable "gcp_region" {
  description = "GCP region"
  type        = string
  default     = "us-central1"
}

`;
          }
        }
        fs.writeFileSync(varsTf, varsContent);
      }

      // Run terraform init
      try {
        const output = execSync('terraform init', { 
          cwd: projectPath,
          encoding: 'utf8',
          timeout: 120000
        });

        // Get providers
        let providersInfo = [];
        try {
          const versionOutput = execSync('terraform providers', {
            cwd: projectPath,
            encoding: 'utf8'
          });
          providersInfo = versionOutput.split('\n').filter(l => l.includes('provider'));
        } catch {}

        return {
          success: true,
          path: projectPath,
          backend: backend.type,
          providers: providersInfo,
          files: fs.readdirSync(projectPath).filter(f => f.endsWith('.tf')),
          message: 'Terraform initialized successfully'
        };
      } catch (error) {
        return {
          success: false,
          error: error.message,
          hint: 'Check your provider credentials and network connectivity'
        };
      }
    }
  },

  // Plan infrastructure changes
  terraform_plan: {
    name: 'terraform_plan',
    description: 'Preview infrastructure changes with optional cost estimation',
    inputSchema: {
      type: 'object',
      properties: {
        path: { type: 'string', description: 'Path to Terraform project' },
        vars: { type: 'object', description: 'Variable values to pass' },
        varFile: { type: 'string', description: 'Path to .tfvars file' },
        target: { type: 'string', description: 'Target specific resource' },
        destroy: { type: 'boolean', description: 'Plan for destruction' }
      },
      required: ['path']
    },
    handler: async (args) => {
      const projectPath = args.path;
      const vars = args.vars || {};
      const varFile = args.varFile;
      const target = args.target;
      const destroy = args.destroy || false;

      if (!fs.existsSync(projectPath)) {
        return { success: false, error: 'Project path does not exist' };
      }

      // Build command
      let cmd = 'terraform plan -no-color';
      
      if (destroy) cmd += ' -destroy';
      if (target) cmd += ` -target=${target}`;
      if (varFile) cmd += ` -var-file=${varFile}`;
      
      // Add variables
      for (const [key, value] of Object.entries(vars)) {
        cmd += ` -var="${key}=${value}"`;
      }

      try {
        const output = execSync(cmd, {
          cwd: projectPath,
          encoding: 'utf8',
          timeout: 300000,
          maxBuffer: 10 * 1024 * 1024
        });

        // Parse output for changes
        const changes = {
          add: 0,
          change: 0,
          destroy: 0
        };

        const planMatch = output.match(/Plan: (\d+) to add, (\d+) to change, (\d+) to destroy/);
        if (planMatch) {
          changes.add = parseInt(planMatch[1]);
          changes.change = parseInt(planMatch[2]);
          changes.destroy = parseInt(planMatch[3]);
        }

        const noChanges = output.includes('No changes');

        return {
          success: true,
          path: projectPath,
          noChanges,
          changes,
          summary: noChanges 
            ? 'Infrastructure is up-to-date'
            : `Plan: ${changes.add} to add, ${changes.change} to change, ${changes.destroy} to destroy`,
          output: output.slice(0, 5000) // Truncate large output
        };
      } catch (error) {
        return {
          success: false,
          error: error.message,
          hint: 'Run terraform init first if not initialized'
        };
      }
    }
  },

  // Apply infrastructure changes
  terraform_apply: {
    name: 'terraform_apply',
    description: 'Apply infrastructure changes with state management',
    inputSchema: {
      type: 'object',
      properties: {
        path: { type: 'string', description: 'Path to Terraform project' },
        vars: { type: 'object', description: 'Variable values to pass' },
        varFile: { type: 'string', description: 'Path to .tfvars file' },
        target: { type: 'string', description: 'Target specific resource' },
        autoApprove: { type: 'boolean', description: 'Skip approval prompt (use with caution)' },
        destroy: { type: 'boolean', description: 'Destroy infrastructure' }
      },
      required: ['path']
    },
    handler: async (args) => {
      const projectPath = args.path;
      const vars = args.vars || {};
      const varFile = args.varFile;
      const target = args.target;
      const autoApprove = args.autoApprove || false;
      const destroy = args.destroy || false;

      if (!fs.existsSync(projectPath)) {
        return { success: false, error: 'Project path does not exist' };
      }

      // Build command
      let cmd = destroy ? 'terraform destroy' : 'terraform apply';
      cmd += ' -no-color';
      
      if (autoApprove) cmd += ' -auto-approve';
      if (target) cmd += ` -target=${target}`;
      if (varFile) cmd += ` -var-file=${varFile}`;
      
      // Add variables
      for (const [key, value] of Object.entries(vars)) {
        cmd += ` -var="${key}=${value}"`;
      }

      if (!autoApprove) {
        return {
          success: false,
          requiresApproval: true,
          command: cmd,
          message: 'Set autoApprove: true to apply changes automatically, or run the command manually'
        };
      }

      try {
        const output = execSync(cmd, {
          cwd: projectPath,
          encoding: 'utf8',
          timeout: 600000, // 10 minutes
          maxBuffer: 10 * 1024 * 1024
        });

        // Parse output
        const resourcesCreated = (output.match(/created/gi) || []).length;
        const resourcesChanged = (output.match(/changed/gi) || []).length;
        const resourcesDestroyed = (output.match(/destroyed/gi) || []).length;

        return {
          success: true,
          path: projectPath,
          action: destroy ? 'destroy' : 'apply',
          resources: {
            created: resourcesCreated,
            changed: resourcesChanged,
            destroyed: resourcesDestroyed
          },
          message: destroy 
            ? 'Infrastructure destroyed successfully'
            : 'Infrastructure applied successfully',
          output: output.slice(-2000) // Last 2000 chars
        };
      } catch (error) {
        return {
          success: false,
          error: error.message,
          hint: 'Check the error output for details'
        };
      }
    }
  },

  // Deploy to Kubernetes
  k8s_deploy: {
    name: 'k8s_deploy',
    description: 'Deploy to Kubernetes cluster with kubectl',
    inputSchema: {
      type: 'object',
      properties: {
        manifest: { type: 'string', description: 'Path to manifest file or directory' },
        namespace: { type: 'string', description: 'Kubernetes namespace' },
        context: { type: 'string', description: 'Kubectl context to use' },
        dryRun: { type: 'boolean', description: 'Dry run mode' },
        wait: { type: 'boolean', description: 'Wait for resources to be ready' }
      },
      required: ['manifest']
    },
    handler: async (args) => {
      const manifest = args.manifest;
      const namespace = args.namespace || 'default';
      const context = args.context;
      const dryRun = args.dryRun || false;
      const wait = args.wait || false;

      // Check kubectl
      try {
        execSync('kubectl version --client', { encoding: 'utf8' });
      } catch {
        return {
          success: false,
          error: 'kubectl is not installed or not in PATH'
        };
      }

      if (!fs.existsSync(manifest)) {
        return { success: false, error: `Manifest not found: ${manifest}` };
      }

      // Build command
      let cmd = 'kubectl apply';
      cmd += ` -f "${manifest}"`;
      cmd += ` -n ${namespace}`;
      if (context) cmd += ` --context=${context}`;
      if (dryRun) cmd += ' --dry-run=client';

      try {
        const output = execSync(cmd, {
          encoding: 'utf8',
          timeout: 120000
        });

        // Parse deployed resources
        const deployed = output.split('\n')
          .filter(l => l.includes('configured') || l.includes('created') || l.includes('unchanged'))
          .map(l => {
            const match = l.match(/^(\S+)\s+(configured|created|unchanged)/);
            return match ? { resource: match[1], status: match[2] } : null;
          })
          .filter(Boolean);

        // Wait for rollout if requested
        if (wait && !dryRun) {
          const deployments = deployed.filter(d => d.resource.includes('deployment'));
          for (const dep of deployments) {
            const depName = dep.resource.split('/')[1];
            try {
              execSync(`kubectl rollout status deployment/${depName} -n ${namespace} --timeout=300s`, {
                encoding: 'utf8'
              });
            } catch (e) {
              // Timeout or error, continue
            }
          }
        }

        return {
          success: true,
          manifest,
          namespace,
          dryRun,
          deployed,
          count: deployed.length,
          message: dryRun 
            ? 'Dry run completed'
            : `Deployed ${deployed.length} resources to ${namespace}`
        };
      } catch (error) {
        return {
          success: false,
          error: error.message
        };
      }
    }
  },

  // Install Helm chart
  helm_install: {
    name: 'helm_install',
    description: 'Install or upgrade Helm charts',
    inputSchema: {
      type: 'object',
      properties: {
        release: { type: 'string', description: 'Release name' },
        chart: { type: 'string', description: 'Chart name or path' },
        repo: { type: 'string', description: 'Helm repository URL' },
        repoName: { type: 'string', description: 'Repository name for helm repo add' },
        namespace: { type: 'string', description: 'Kubernetes namespace' },
        values: { type: 'object', description: 'Values to override' },
        valuesFile: { type: 'string', description: 'Path to values.yaml file' },
        version: { type: 'string', description: 'Chart version' },
        dryRun: { type: 'boolean', description: 'Dry run mode' },
        wait: { type: 'boolean', description: 'Wait for resources to be ready' }
      },
      required: ['release', 'chart']
    },
    handler: async (args) => {
      const release = args.release;
      const chart = args.chart;
      const repo = args.repo;
      const repoName = args.repoName;
      const namespace = args.namespace || 'default';
      const values = args.values || {};
      const valuesFile = args.valuesFile;
      const version = args.version;
      const dryRun = args.dryRun || false;
      const wait = args.wait || true;

      // Check helm
      try {
        execSync('helm version --short', { encoding: 'utf8' });
      } catch {
        return {
          success: false,
          error: 'Helm is not installed or not in PATH'
        };
      }

      // Add repo if specified
      if (repo && repoName) {
        try {
          execSync(`helm repo add ${repoName} ${repo}`, { encoding: 'utf8' });
          execSync('helm repo update', { encoding: 'utf8' });
        } catch (e) {
          // Repo might already exist
        }
      }

      // Build command
      let cmd = `helm upgrade --install ${release} ${chart}`;
      cmd += ` -n ${namespace} --create-namespace`;
      if (version) cmd += ` --version ${version}`;
      if (valuesFile && fs.existsSync(valuesFile)) cmd += ` -f "${valuesFile}"`;
      if (dryRun) cmd += ' --dry-run';
      if (wait) cmd += ' --wait --timeout=5m';

      // Add values
      for (const [key, value] of Object.entries(values)) {
        cmd += ` --set ${key}=${value}`;
      }

      try {
        const output = execSync(cmd, {
          encoding: 'utf8',
          timeout: 600000
        });

        // Get release status
        let status = {};
        if (!dryRun) {
          try {
            const statusOutput = execSync(`helm status ${release} -n ${namespace} -o json`, {
              encoding: 'utf8'
            });
            status = JSON.parse(statusOutput);
          } catch {}
        }

        return {
          success: true,
          release,
          chart,
          namespace,
          version: version || 'latest',
          dryRun,
          status: status.info?.status || 'deployed',
          message: dryRun
            ? 'Dry run completed successfully'
            : `Helm release "${release}" deployed to namespace "${namespace}"`
        };
      } catch (error) {
        return {
          success: false,
          error: error.message
        };
      }
    }
  }
};

module.exports = iacTools;
